"""
Test suite for RoundRobin tournament pairing system.

This module tests the RoundRobin class to ensure it correctly implements
FIDE-compliant round-robin tournaments with proper pairings, bye handling,
and tournament structure validation.
"""

from collections import Counter, defaultdict
from typing import List, Optional, Set, Tuple

import pytest

from gambitpairing import BERGER_TABLES, RoundRobin, create_round_robin_pairings
from gambitpairing.exceptions import PairingException
from gambitpairing.pairing_round_robin import (
    BERGER_TABLES,
    RoundRobin,
    create_round_robin_pairings,
)
from gambitpairing.player import Player


class TestRoundRobinBasic:
    """Test basic RoundRobin functionality and initialization."""

    def test_valid_player_counts(self):
        """Test that RoundRobin accepts valid player counts (3-16)."""
        for n in range(3, 17):
            players = [Player(f"Player{i}") for i in range(n)]
            tournament = RoundRobin(players)
            assert len(tournament.players) == n
            assert tournament.number_of_rounds > 0

    def test_invalid_player_counts(self):
        """Test that RoundRobin rejects invalid player counts."""
        # Too few players
        with pytest.raises(PairingException):
            RoundRobin([Player("A"), Player("B")])

        with pytest.raises(PairingException):
            RoundRobin([Player("A")])

        with pytest.raises(PairingException):
            RoundRobin([])

        # Too many players
        players_17 = [Player(f"Player{i}") for i in range(17)]
        with pytest.raises(PairingException):
            RoundRobin(players_17)

        players_20 = [Player(f"Player{i}") for i in range(20)]
        with pytest.raises(PairingException):
            RoundRobin(players_20)

    def test_player_order_preservation(self):
        """Test that player order is preserved in the tournament."""
        players = [Player("Alice"), Player("Bob"), Player("Charlie"), Player("David")]
        tournament = RoundRobin(players)

        for i, player in enumerate(players):
            assert tournament.players[i] == player


class TestRoundRobinStructure:
    """Test tournament structure and round organization."""

    def test_correct_number_of_rounds(self):
        """Test that tournaments have the correct number of rounds."""
        test_cases = [
            (3, 3),
            (4, 3),  # 3-4 players: 3 rounds
            (5, 5),
            (6, 5),  # 5-6 players: 5 rounds
            (7, 7),
            (8, 7),  # 7-8 players: 7 rounds
            (9, 9),
            (10, 9),  # 9-10 players: 9 rounds
            (11, 11),
            (12, 11),  # 11-12 players: 11 rounds
            (13, 13),
            (14, 13),  # 13-14 players: 13 rounds
            (15, 15),
            (16, 15),  # 15-16 players: 15 rounds
        ]

        for n_players, expected_rounds in test_cases:
            players = [Player(f"P{i}") for i in range(n_players)]
            tournament = RoundRobin(players)
            assert tournament.number_of_rounds == expected_rounds
            assert len(tournament.round_pairings) == expected_rounds

    def test_bye_assignment_odd_players(self):
        """Test that bye players are correctly assigned for odd numbers."""
        odd_player_counts = [3, 5, 7, 9, 11, 13, 15]

        for n in odd_player_counts:
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            # Should have bye number set
            assert tournament.bye_number is not None

            # Check that exactly one player gets a bye in each round
            bye_count = 0
            for matches, bye_player in tournament.round_pairings:
                if bye_player is not None:
                    bye_count += 1
                    assert bye_player in tournament.players

            # All rounds should have exactly one bye
            assert bye_count == tournament.number_of_rounds

    def test_no_bye_even_players(self):
        """Test that no byes are assigned for even numbers of players."""
        even_player_counts = [4, 6, 8, 10, 12, 14, 16]

        for n in even_player_counts:
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            # Should not have bye number set
            assert tournament.bye_number is None

            # Check that no player gets a bye in any round
            for matches, bye_player in tournament.round_pairings:
                assert bye_player is None


class TestRoundRobinPairings:
    """Test the actual pairings generated by the tournament."""

    def test_all_players_paired_each_round(self):
        """Test that all active players are paired in each round."""
        for n in range(3, 17):
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            for round_num, (matches, bye_player) in enumerate(
                tournament.round_pairings
            ):
                # Count players in matches
                players_in_matches = set()
                for p1, p2 in matches:
                    players_in_matches.add(p1)
                    players_in_matches.add(p2)

                # Add bye player if exists
                if bye_player is not None:
                    players_in_matches.add(bye_player)

                # Should account for all players
                assert len(players_in_matches) == n
                assert players_in_matches == set(tournament.players)

    def test_no_duplicate_matches_in_round(self):
        """Test that no player appears twice in the same round."""
        for n in range(3, 17):
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            for round_num, (matches, bye_player) in enumerate(
                tournament.round_pairings
            ):
                players_seen = []

                for p1, p2 in matches:
                    assert (
                        p1 != p2
                    ), f"Player {p1} paired with themselves in round {round_num + 1}"
                    players_seen.extend([p1, p2])

                # Check for duplicates
                assert len(players_seen) == len(
                    set(players_seen)
                ), f"Duplicate player in round {round_num + 1}"

    def test_round_robin_completeness(self):
        """Test that every player plays every other player exactly once."""
        for n in range(3, 17):
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            # Track all pairings across all rounds
            all_pairings = set()

            for matches, bye_player in tournament.round_pairings:
                for p1, p2 in matches:
                    # Store pairing in canonical form (smaller, larger)
                    pairing = (p1, p2) if p1.name <= p2.name else (p2, p1)

                    # Check for duplicate pairings
                    assert pairing not in all_pairings, f"Duplicate pairing: {pairing}"

                    all_pairings.add(pairing)

            # Calculate expected number of unique pairings
            # For n players, there should be C(n,2) = n*(n-1)/2 pairings
            expected_pairings = n * (n - 1) // 2

            assert (
                len(all_pairings) == expected_pairings
            ), f"Expected {expected_pairings} unique pairings, got {len(all_pairings)}"

    def test_player_plays_correct_number_of_games(self):
        """Test that each player plays the correct number of games."""
        for n in range(3, 17):
            players = [Player(f"P{i}") for i in range(n)]
            tournament = RoundRobin(players)

            # Count games per player
            game_counts = defaultdict(int)
            bye_counts = defaultdict(int)

            for matches, bye_player in tournament.round_pairings:
                for p1, p2 in matches:
                    game_counts[p1] += 1
                    game_counts[p2] += 1

                if bye_player is not None:
                    bye_counts[bye_player] += 1

            # Each player should play exactly (n-1) games
            for player in players:
                expected_games = n - 1
                actual_games = game_counts[player]
                actual_byes = bye_counts[player]

                assert (
                    actual_games == expected_games
                ), f"Player {player} played {actual_games} games, expected {expected_games}"

                # For odd tournaments, each player should get exactly one bye
                if n % 2 == 1:
                    assert (
                        actual_byes == 1
                    ), f"Player {player} got {actual_byes} byes, expected 1"
                else:
                    assert (
                        actual_byes == 0
                    ), f"Player {player} got {actual_byes} byes, expected 0"


class TestRoundRobinMethods:
    """Test the public methods of the RoundRobin class."""

    def test_get_round_pairings_valid_rounds(self):
        """Test getting pairings for valid round numbers."""
        players = [Player(f"P{i}") for i in range(4)]
        tournament = RoundRobin(players)

        # Test all valid rounds (1-indexed)
        for round_num in range(1, tournament.number_of_rounds + 1):
            pairings = tournament.get_round_pairings(round_num)
            matches, bye_player = pairings

            assert isinstance(matches, tuple)
            assert all(
                isinstance(match, tuple) and len(match) == 2 for match in matches
            )
            assert bye_player is None or isinstance(bye_player, Player)

    def test_get_round_pairings_invalid_rounds(self):
        """Test that invalid round numbers raise exceptions."""
        players = [Player(f"P{i}") for i in range(4)]
        tournament = RoundRobin(players)

        # Test invalid round numbers
        invalid_rounds = [
            0,
            -1,
            tournament.number_of_rounds + 1,
            tournament.number_of_rounds + 5,
        ]

        for invalid_round in invalid_rounds:
            with pytest.raises(PairingException):
                tournament.get_round_pairings(invalid_round)

    def test_get_all_pairings(self):
        """Test getting all pairings at once."""
        players = [Player(f"P{i}") for i in range(5)]
        tournament = RoundRobin(players)

        all_pairings = tournament.get_all_pairings()

        assert isinstance(all_pairings, tuple)
        assert len(all_pairings) == tournament.number_of_rounds

        # Should match individual round pairings
        for i, pairings in enumerate(all_pairings):
            expected = tournament.get_round_pairings(i + 1)
            assert pairings == expected

    def test_get_player_schedule(self):
        """Test getting a player's complete schedule."""
        players = [Player("Alice"), Player("Bob"), Player("Charlie"), Player("David")]
        tournament = RoundRobin(players)
        alice = players[0]

        schedule = tournament.get_player_schedule(alice)

        # Should have entry for each round
        assert len(schedule) == tournament.number_of_rounds

        # Each entry should be (round_number, opponent)
        opponents = set()
        for round_num, opponent in schedule:
            assert 1 <= round_num <= tournament.number_of_rounds
            if opponent is not None:
                assert opponent in players
                assert opponent != alice
                opponents.add(opponent)

        # Alice should play against all other players exactly once
        expected_opponents = set(players) - {alice}
        assert opponents == expected_opponents

    def test_get_player_schedule_invalid_player(self):
        """Test that invalid player raises exception for schedule."""
        players = [Player(f"P{i}") for i in range(4)]
        tournament = RoundRobin(players)

        invalid_player = Player("NotInTournament")

        with pytest.raises(PairingException):
            tournament.get_player_schedule(invalid_player)


class TestRoundRobinSpecialCases:
    """Test special cases and edge conditions."""

    def test_minimum_tournament_size(self):
        """Test tournament with minimum 3 players."""
        players = [Player("A"), Player("B"), Player("C")]
        tournament = RoundRobin(players)

        assert len(tournament.players) == 3
        assert tournament.number_of_rounds == 3
        assert (
            tournament.bye_number == 3
        )  # Player index 3 (doesn't exist) represents bye

        # Each round should have 1 match + 1 bye
        for matches, bye_player in tournament.round_pairings:
            assert len(matches) == 1
            assert bye_player is not None

    def test_maximum_tournament_size(self):
        """Test tournament with maximum 16 players."""
        players = [Player(f"P{i}") for i in range(16)]
        tournament = RoundRobin(players)

        assert len(tournament.players) == 16
        assert tournament.number_of_rounds == 15
        assert tournament.bye_number is None

        # Each round should have 8 matches, no byes
        for matches, bye_player in tournament.round_pairings:
            assert len(matches) == 8
            assert bye_player is None

    def test_string_representations(self):
        """Test string representations of tournament."""
        players = [Player("Alice"), Player("Bob"), Player("Charlie")]
        tournament = RoundRobin(players)

        # Test __str__
        str_repr = str(tournament)
        assert "Round Robin Tournament" in str_repr
        assert "3 players" in str_repr
        assert "3 rounds" in str_repr

        # Test __repr__
        repr_str = repr(tournament)
        assert "RoundRobin" in repr_str
        assert "players=3" in repr_str
        assert "rounds=3" in repr_str


class TestCreateRoundRobinPairings:
    """Test the factory function create_round_robin_pairings."""

    def test_factory_function(self):
        """Test that the factory function works correctly."""
        players = [Player(f"P{i}") for i in range(6)]

        pairings = create_round_robin_pairings(players)

        assert isinstance(pairings, tuple)
        assert len(pairings) == 5  # 5-6 player tournament has 5 rounds

        # Each pairing should be properly formatted
        for round_pairings in pairings:
            matches, bye_player = round_pairings
            assert isinstance(matches, tuple)
            assert bye_player is None or isinstance(bye_player, Player)

    def test_factory_function_invalid_input(self):
        """Test that factory function handles invalid input."""
        # Too few players
        with pytest.raises(PairingException):
            create_round_robin_pairings([Player("A")])

        # Too many players
        players_20 = [Player(f"P{i}") for i in range(20)]
        with pytest.raises(PairingException):
            create_round_robin_pairings(players_20)


class TestBergerTables:
    """Test that Berger tables are properly structured."""

    def test_berger_table_structure(self):
        """Test that all Berger tables have proper structure."""
        for table_name, table in BERGER_TABLES.items():
            # Should be tuple of rounds
            assert isinstance(table, tuple)

            # Each round should be tuple of pairings
            for round_schedule in table:
                assert isinstance(round_schedule, tuple)

                # Each pairing should be tuple of two integers
                for pairing in round_schedule:
                    assert isinstance(pairing, tuple)
                    assert len(pairing) == 2
                    assert all(isinstance(x, int) for x in pairing)

    def test_berger_table_coverage(self):
        """Test that we have Berger tables for all supported sizes."""
        expected_tables = ["3-4", "5-6", "7-8", "9-10", "11-12", "13-14", "15-16"]

        for table_name in expected_tables:
            assert table_name in BERGER_TABLES, f"Missing Berger table: {table_name}"


# Pytest fixtures for common test data
@pytest.fixture
def small_tournament():
    """Fixture for a small 4-player tournament."""
    players = [Player("Alice"), Player("Bob"), Player("Charlie"), Player("David")]
    return RoundRobin(players)


@pytest.fixture
def medium_tournament():
    """Fixture for a medium 8-player tournament."""
    players = [Player(f"Player{i}") for i in range(8)]
    return RoundRobin(players)


@pytest.fixture
def large_tournament():
    """Fixture for a large 12-player tournament."""
    players = [Player(f"P{i}") for i in range(12)]
    return RoundRobin(players)


# Integration tests using fixtures
class TestRoundRobinIntegration:
    """Integration tests using fixtures."""

    def test_small_tournament_complete_cycle(self, small_tournament):
        """Test complete tournament cycle for small tournament."""
        tournament = small_tournament

        # Verify basic properties
        assert len(tournament.players) == 4
        assert tournament.number_of_rounds == 3
        assert tournament.bye_number is None

        # Verify each player plays 3 games total
        total_games = defaultdict(int)
        for matches, bye_player in tournament.round_pairings:
            for p1, p2 in matches:
                total_games[p1] += 1
                total_games[p2] += 1

        for player in tournament.players:
            assert total_games[player] == 3

    def test_medium_tournament_bye_handling(self):
        """Test bye handling in odd-numbered tournament."""
        # Create tournament with 7 players (odd)
        players = [Player(f"P{i}") for i in range(7)]
        tournament = RoundRobin(players)

        # Track bye distribution
        bye_distribution = defaultdict(int)

        for matches, bye_player in tournament.round_pairings:
            if bye_player is not None:
                bye_distribution[bye_player] += 1

        # Each player should get exactly one bye
        for player in players:
            assert bye_distribution[player] == 1

    def test_large_tournament_pairing_quality(self, large_tournament):
        """Test pairing quality metrics for large tournament."""
        tournament = large_tournament

        # Color balance would be tested here if we had color information
        # For now, just verify structural integrity

        all_matches = []
        for matches, bye_player in tournament.round_pairings:
            all_matches.extend(matches)

        # Should have exactly C(12,2) = 66 unique matches
        assert len(all_matches) == 66

        # No duplicate matches
        canonical_matches = set()
        for p1, p2 in all_matches:
            match = (p1, p2) if p1.name <= p2.name else (p2, p1)
            assert match not in canonical_matches, f"Duplicate match: {match}"
            canonical_matches.add(match)


def run_tests():
    # Run a subset of tests if pytest is not available
    print("Running basic tests...")

    # Test basic functionality
    try:
        # Test valid tournament creation
        players = [Player(f"P{i}") for i in range(4)]
        tournament = RoundRobin(players)
        print(f"✓ Created tournament with {len(tournament.players)} players")

        # Test round pairings
        for i in range(1, tournament.number_of_rounds + 1):
            pairings = tournament.get_round_pairings(i)
            print(f"✓ Round {i}: {len(pairings[0])} matches")

        # Test invalid player count
        try:
            RoundRobin([Player("A")])
            print("✗ Should have failed with too few players")
        except PairingException:
            print("✓ Correctly rejected too few players")

        print("\nBasic tests passed! Run with pytest for full test suite.")

    except Exception as e:
        print(f"✗ Test failed: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    run_tests()

#  LocalWords:  RoundRobin
